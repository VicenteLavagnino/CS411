<!DOCTYPE html>
<html>
  <!-- (C) F. Tusell, 2017. Licensed under GPL v 3.0 -->
  <head>
    <meta charset='utf-8'>
    <title>CS411 - EPFL Game</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.2.6/interact.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <style>
     body { margin: 0; padding: 0; }
     #controls {
	 position: fixed;
	 top: 10px;
	 left: 10px;
	 z-index: 1000;
	 background-color: rgba(255, 255, 255, 0.9);
	 padding: 10px;
	 border-radius: 8px;
	 box-shadow: 0 2px 10px rgba(0,0,0,0.3);
     }
     #map{ 
	 height: 100vh; 
	 width: 100vw;
     }
     .button {
	 -moz-border-radius: 8px;
	 -webkit-border-radius: 8px;
	 background-color: #ffe4c4;
	 border-radius: 8px;
	 border: 2px groove;
	 color: black;
	 display: inline-block;
	 height: 35px;
	 line-height: 31px;
	 margin: 5px;
	 text-align: center;
	 text-decoration: none;
	 width: 120px;
	 cursor: pointer;
     }
     .button:hover {
	 background-color: #ffd700;
     }
     #info {
	 position: fixed;
	 top: 10px;
	 right: 10px;
	 z-index: 1000;
	 background-color: rgba(255, 255, 255, 0.9);
	 padding: 10px;
	 border-radius: 8px;
	 box-shadow: 0 2px 10px rgba(0,0,0,0.3);
	 font-size: 14px;
     }
    </style>
  </head>
  <body>
    <div id="info">
      <b>Last search:</b> <i id="LastSearch">none yet</i><br/>
      <b>Searches:</b> <i id="Searches">0</i><br/>
      <b>Correct:</b> <i id="Correct">0</i><br/>
      <b>Incorrect:</b> <i id="Incorrect">0</i><br/>
      <b>Points:</b> <i id="Points">0</i>
    </div>
    
    <div id="controls">
      <input id='start' class="button" type="button" value="Start" onClick="start()">
      <input id='search' class="button" type="button" value="Search" onClick="search(last)">
    </div>
    
    <div id="map"></div>

      <script>
       var Correct   =  document.getElementById("Correct")
       correct   = 0 ;
       maxSearches     = 0 ;
       var detectProb     =  0.6     // detection probability in a search
       var fillColor ;
       var Incorrect =  document.getElementById("Incorrect")
       incorrect = 0 ;
       var numSectors   = 9 ;
       oldProbs    = [] ;
       probs       = [] ;
       var Points      =  document.getElementById("Points")
       points      = 0 ;
       searches    = 0 ;
       var Searches    =  document.getElementById("Searches")
       sectorNames    = [" ", " ", " ", " ", " ", " ", " ", " ", " "] ;
       var LastSearch  =  document.getElementById("LastSearch")
       last      = "none yet" ;

       // initialize the map when ready
       function initializeMap() {
	   if (typeof L !== 'undefined') {
	       map = L.map('map').setView([35, -30], 6);

	       // load the tiles
	       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
		   attribution: 'Map &copy; <a href="http://openstreetmap.org">OpenStreetMap</a>',
		   maxZoom: 18,
	       }).addTo(map);
	       
	       // Initialize sectors after the map is ready
	       initializeSectors();
	   } else {
	       // If Leaflet is not ready, try again in 100ms
	       setTimeout(initializeMap, 100);
	   }
       }
       
       function initializeSectors() {
	   // Create sectors after the map is ready
	   sect = L.geoJson(sectors, {
	       style: function(feature){
		   // randomize the a priori probabilities
		   // color according to the a priori probability
		   var fillColor,
		       apriori = feature.properties.apriori;
		   if ( apriori > 0.30 ) fillColor = "#006837";
		   else if ( apriori > 0.20 ) fillColor = "#31a354";
		   else if ( apriori > 0.15 ) fillColor = "#78c679";
		   else if ( apriori > 0.10 ) fillColor = "#c2e699";
		   else if ( apriori > 0 ) fillColor = "#ffffcc";
		   else fillColor = "#f7f7f7";  // no data
		   return { color: "#999", weight: 1, fillColor: fillColor, fillOpacity: .6 };
	       },
	       onEachFeature: function( feature, layer ){
		   layer.bindPopup( "<b>Sector:&nbsp" + feature.properties.name +
				"<br/>Prior prob:</b>  " +
				feature.properties.apriori)
	       } }
	   ).addTo(map) ;
       }
       
       // Initialize the map when the DOM is ready
       if (document.readyState === 'loading') {
	   document.addEventListener('DOMContentLoaded', initializeMap);
       } else {
	   initializeMap();
       }

       var sectors = {
	   "type": "FeatureCollection",
	   "crs": { "type":"name",  "properties": { "name":"urn:ogc:def:crs:OGC:1.3:CRS84"  }   },
	   "features":   [
	       {"type": "Feature", "id":"01", "properties": { "name": "C1","apriori": 0 },
		"geometry": { "type":  "Polygon",
			      "coordinates": [[[-39.0, 32.0],[-35.0, 32.0],[-35.0, 34.0],
					       [-39.0, 34.0],[-39.0, 32.0 ]]]}},
	       {"type":"Feature","id":"02","properties":{"name":"B1","apriori": 0},
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-39,34],[-35,34],[-35,36],[-39,36],
					     [-39,34]]]]}},
	       {"type":"Feature","id":"03","properties":{"name":"A1","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-39,36],[-35,36],[-35,38],[-39,38],
					     [-39,34]]]]}},
	       {"type":"Feature","id":"04","properties":{"name":"C2","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-35,32],[-31,32],[-31,34],[-35,34],
					     [-35,32]]]]}},
	       {"type":"Feature","id":"05","properties":{"name":"B2","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-35,34],[-31,34],[-31,36],[-35,36],
					     [-35,35]]]]}},
	       {"type":"Feature","id":"06","properties":{"name":"A2","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-35,36],[-31,36],[-31,38],[-35,38],
					     [-35,36]]]]}},
	       {"type":"Feature","id":"07","properties":{"name":"C3","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-31,32],[-27,32],[-27,34],[-31,34],
					     [-31,32]]]]}},
	       {"type":"Feature","id":"08","properties":{"name":"B3","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-31,34],[-27,34],[-27,36],[-31,36],
					     [-31,34]]]]}},
	       {"type":"Feature","id":"09","properties":{"name":"A3","apriori": 0 },
		"geometry":{"type":"MultiPolygon",
			    "coordinates":[[[[-31,36],[-27,36],[-27,38],[-31,38],
					     [-31,36]]]]}} ] }


       // var sub = L.geojson(submarker, {
       //	    $.getJSON("puntos.geojson",function(data){
       //	      var subIcon = L.icon({
       //	      iconUrl: 'sub.png',
       //	      iconSize: [45,36]
       //	      });
       //	      L.geoJson(data,{
       //	      pointToLayer: function(feature,latlng){
       //	      var marker = L.marker(latlng,{icon: subIcon});
       //	      marker.bindPopup(feature.properties.Location + '<br/>' + feature.properties.OPEN_DT);
       //	      return marker;
       //	      }
       //	      }).addTo(map);
       //	    * });*/



       function indexOfMax(arr) {  // StackOverflow, Apr. 5, 2016. "Return index of greatest value in an array"
	   if (arr.length === 0) {
	       return -1;
	   }
	   var max = arr[0];
	   var maxIndex = 0;
	   for (var i = 1; i < arr.length; i++) {
	       if (arr[i] > max) {
		   maxIndex = i;
		   max = arr[i];
	       }
	   }
	   return maxIndex;
       }

       function search(last) {

	  // find index of the searched sector

	  var k = -1;
	  for (var i=0; i < numSectors ; i++) {
	      if (last == sectorNames[i]) {
		 k = i ;
		 break ;
	      }
	  }

	   var j = indexOfMax(probs) ;
	   correctSector = sectorNames[j] ;

	   // update the banners

	   searches = searches + 1 ;
	   Searches.innerHTML = searches ;
	   LastSearch.innerHTML = last ;

	   if (last == correctSector) {
	       correct = correct + 1;
	       Correct.innerHTML = correct ;
	   } else {
	       incorrect = incorrect + 1;
	       Incorrect.innerHTML = incorrect ;
	   }
	   points = ( 10*(correct / searches) ).toFixed(4) ;
	   Points.innerHTML = points ;
	   if (searches > maxSearches) {
	       alert("You found it") ;
	       start() ;
	   } else {

	       // generate a posteriori probabilities
	    sum = 0 ;
	       for (i=0; i < numSectors ; i++) {
		   if (i != k) {
		       // if the sector is not the last searched...
		       probs[i] = oldProbs[i] / ( 1 - detectProb*oldProbs[k] ) ;
	       } else {
		       // otherwise...
		       probs[i] = ( (1 - detectProb)*oldProbs[i] ) / ( 1 - detectProb*oldProbs[i] )
		   }
		   sum = sum + probs[i] ;
	       }

	       for (i=0; i < numSectors ; i++) {
		   probs[i] = probs[i] / sum ;
		   sectors.features[i].properties.apriori = ( oldProbs[i] ).toFixed(3) ;
	       }

	       // replace the sector grid with a new one

	       map.removeLayer(sect)

	       // we will show the coloring that corresponds to the probabilities
	       // **before** being revised with the result of the last search

	       sect = L.geoJson(sectors, {
		   style: function(feature){
		       // color
		       var fillColor,
			   apriori = feature.properties.apriori;
		       if ( apriori > 0.30 ) fillColor = "#006837";
		   else if ( apriori > 0.20 ) fillColor = "#31a354";
		   else if ( apriori > 0.15 ) fillColor = "#78c679";
		   else if ( apriori > 0.10 ) fillColor = "#c2e699";
		   else if ( apriori > 0 ) fillColor = "#ffffcc";
		   else fillColor = "#f7f7f7";  // no data
		       return { color: "#999", weight: 1, fillColor: fillColor, fillOpacity: .6 };
		   },
		   onEachFeature: function( feature, layer ){
		       layer.bindPopup( "<b>Sector:&nbsp" + feature.properties.name +
					"<br/>Before last search:</b> p = " +
					feature.properties.apriori +
					"<br><b>Last search:</b> " + last)
		   } }
	       ) ;
	       sect.addTo(map) ;

	       // update the a priori probabilities

	       for (i=0; i < numSectors ; i++) {
		   oldProbs[i] = probs[i] ;
	       }
	   }
       } ;


       // definition and properties of the search ship

       var shipIcon = L.icon({
	   iconUrl: 'battleship.png',
	   iconSize: [60,45]
       });

       // ship is global, because it's declared without "var"

       ship = L.marker([32.5, -41.0],{icon:shipIcon, draggable: true})

       ship.on('click', function(e) {
	   search(last) ;
       }) ;

       ship.on('dragend', function(e) {

	   // determine which sector we are in

	   var d1="X", d2="X" ;
	   lon = this.getLatLng().lng ;
	   lat = this.getLatLng().lat ;

	   if ((lat >= 32) & (lat <= 34))
	       d1 = "C"
	   else if ((lat >= 34) & (lat <= 36))
	       d1 = "B"
	   else if  ((lat >= 36) & (lon <= 38))
	       d1 = "A"
	   if ((lon >= -39) & (lon <= -35))
	       d2 = "1"
	   else if ((lon >= -35) & (lon <= -31))
	       d2 = "2"
	   else if  ((lon >= -31) & (lon <= -27))
	       d2 = "3"

	   // if any coordinate could not be determined, ask the user to
	   // place the search ship well within one of the sectors;

	   if (d1=="X" | d2=="X")
	       alert("Please place the search ship well within one of the sectors.")

	   // otherwise, take note of the sector we are in.

	   else
	       last = d1 + d2 ;
	   document.getElementById("search").value = "Search " + last ;
       });


      </script>

      <script>
       // Ensure ship variable is available globally
       if (typeof ship === 'undefined') {
	   var shipIcon = L.icon({
	       iconUrl: 'battleship.png',
	       iconSize: [60,45]
	   });
	   ship = L.marker([32.5, -41.0],{icon:shipIcon, draggable: true});
	   
	   ship.on('click', function(e) {
	       search(last);
	   });
	   
	   ship.on('dragend', function(e) {
	       var d1="X", d2="X";
	       var lon = this.getLatLng().lng;
	       var lat = this.getLatLng().lat;
	       
	       if ((lat >= 32) & (lat <= 34))
		   d1 = "C";
	       else if ((lat >= 34) & (lat <= 36))
		   d1 = "B";
	       else if ((lat >= 36) & (lat <= 38))
		   d1 = "A";
	       if ((lon >= -39) & (lon <= -35))
		   d2 = "1";
	       else if ((lon >= -35) & (lon <= -31))
		   d2 = "2";
	       else if ((lon >= -31) & (lon <= -27))
		   d2 = "3";
	       
	       if (d1=="X" || d2=="X")
		   alert("Please place the search ship well within one of the sectors.");
	       else
		   last = d1 + d2;
	       document.getElementById("search").value = "Search " + last;
	   });
       }
       
       // Replace ONLY this function to call /api/backend (Node), not backend.php
       function submitScore(str) {
         var xmlhttp = new XMLHttpRequest();
         // Call to the Vercel serverless function
         xmlhttp.open("GET", "/api/backend?q=" + encodeURIComponent(str), true);
         xmlhttp.send();
       }



       function start() {
	   var startButton = document.getElementById('start') ;
	   if (startButton.value == 'Start') {
	       maxSearches = Math.floor((20*Math.random())) ;
	       ship.addTo(map);
	       startButton.style.color = "blue" ;
	       startButton.value = 'Finish' ;
	       correct = 0 ;
	       incorrect = 0 ;
	       points = 0 ;
	       searches = 0 ;
	       last = "none yet" ;
	       Correct.innerHTML = 0 ;
	       Incorrect.innerHTML = 0 ;
	       Points.innerHTML = 0 ;
	       Searches.innerHTML = 0 ;
	       LastSearch.innerHTML = "none yet" ;
	       // randomize initial probabilities
	       var sum  = 0 ;
	       for (i=0; i < numSectors ; i++) {
		   probs[i] = Math.random() ;
		   sum = sum + probs[i] ;

	       }
	       for (i=0 ; i < numSectors; i++) {
		   probs[i] = probs[i] / sum
		   sectors.features[i].properties.apriori = ( probs[i] ).toFixed(3) ;
		   oldProbs[i] = probs[i]  ;
		   sectorNames[i] =  sectors.features[i].properties.name ;
	       }
	       map.removeLayer(sect)

	       // we will show the coloring that corresponds to the probabilities
	       // **before** being revised with the result of the last search

	       sect = L.geoJson(sectors, {
		   style: function(feature){
		       // color
		       var fillColor,
			   apriori = feature.properties.apriori;
		       if ( apriori > 0.30 ) fillColor = "#006837";
		   else if ( apriori > 0.20 ) fillColor = "#31a354";
		   else if ( apriori > 0.15 ) fillColor = "#78c679";
		   else if ( apriori > 0.10 ) fillColor = "#c2e699";
		   else if ( apriori > 0 ) fillColor = "#ffffcc";
		   else fillColor = "#f7f7f7";  // no data
		       return { color: "#999", weight: 1, fillColor: fillColor, fillOpacity: .6 };
		   },
		   onEachFeature: function( feature, layer ){
		       layer.bindPopup( "<b>Sector:&nbsp" + feature.properties.name +
					"<br/>Before last search:</b> p = " +
					feature.properties.apriori +
					"<br><b>Last search:</b> " + last)
		   } }
	       ) ;
	       sect.addTo(map) ;
	   }
	else if (startButton.value == 'Finish') {
	       alert("Thank you for your response, you can now return to the Moodle activity");
	       startButton.style.color = "black" ;
	       startButton.value = 'Start' ;
	       map.removeLayer(ship) ;
	       // force page reload
	       location.reload() ;
	   }
       }
      </script>
  </body>
</html>
